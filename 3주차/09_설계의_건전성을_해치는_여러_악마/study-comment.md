# 9장 설계의 건전성을 해치는 여러 악마

## 9.1 데드 코드

- 절대 실행되지 않는 조건 내부에 있는 코드
  - 코드의 가독성을 떨어뜨리고 언젠가 버그가 될 가능성이 있다.
  - 발견하는 즉시 제거하자!

## 9.2 YAGNI 원칙

- 미리 구현한 로직은 실제로 거의 사용되지도 않고, 버그의 원인이 되기도 한다.
- ‘You Aren’t Gonna Need It.’ : 지금 필요 없는 기능을 만들지 마라!
- 소프트웨어의 요구는 자주 변하기 때문에 미리 예측하고 구현해도 예측이 대부분 맞지 않는다.

## 9.3 매직 넘버

- 로직 내부에 직접 작성된, 설명이 없는 숫자는 혼란스럽게 만든다.
- 매직 넘버를 사용하지 말고 상수를 활용하자.

```java
private static final int MIN = 0;
private static final int TRIAL_READING_POINT = 60;
```

## 9.4 문자열 자료형에 대한 집착

```java
String title = "타이틀,255,250,240,64";
```

- 하나의 String 변수에 여러 값을 쉼표로 구분해서 저장하고 있다. 의미가 다른 여러 개의 값을 하나의 String 변수에 넣으면 의미를 알기 어렵고, split 메서드를 활용해야하므로 로직이 쓸데없이 복잡해진다.
- 의미가 다른 값은 각각 다른 변수에 저장해라.

## 9.5 전역 변수

```java
public OrderManager {
	public static int currentOrderId;
}
```

- 모든 곳에서 접근하거나 조작할 수 있는 변수
- 여러 로직에서 전역 변수를 참조하고 값을 변경하면, 어디에서 어떤 시점에 값을 변경했는지 파악하기 힘들다. 또한 전역 변수를 참조하고 있는 로직을 변경할 때, 해당 변수를 참조하는 다른 로직에서 버그가 발생하는지도 검토해야 한다.
- 또한 동기화가 필요한 경우에도 문제가 발생한다. 동기화는 제대로 설계하지 않으면 락을 얻기 위해 대기하는 시간이 길어져서 퍼포먼스를 크게 떨어뜨리고, 문제가 생기면 데드락 상태에 빠질 수 있다.

### 9.5.1 영향 범위가 최소화되도록 설계하기

- 관계없는 로직에서는 접근할 수 없게 설계해라. 호출할 수 있는 위치가 적고 국소적일수록 로직을 이해하고 구현하기 쉽다.

## 9.6 null 문제

```java
void showBodyEquipment {
	showParam(body.name);
	showParam(body.defence);
	showParam(body.magicDefence);
}
```

- 초기화하지 않은 메모리 영역에서 값을 읽으면 문제가 된다. 이를 피하기 위해 null이 발명된 것이다.
- null은 메모리 접근과 관련된 문제를 방지하기 위한 최소한의 구조로서, null 자체가 ‘잘못된 처리’를 의미한다.

### 9.6.1 null을 리턴/전달하지 말기

- null 체크를 하지 않으려면, 애초에 null을 다루지 않게 만들어야 한다.
  - null을 리턴하지 않는 설계
  - null을 전달하지 않는 설계

```java
class Equipment {
	static final Equipment EMPTY = new Equipment("장비 없음", 0, 0, 0);
}

void takeOffAllEquipments() {
	head = Equipment.EMPTY;
	body = Equipment.EMPTY;
	arm = Equipment.EMPTY;
}

void takeOffAllEquipments() {
	head = null;
	body = null;
	arm = null;
}
```

- 이처럼 장비하지 않은 상태를 포함해서 head, body, arm에 항상 인스턴스가 존재하게 만들면, null 예외가 발생할 걱정을 하지 않아도 된다.

### 9.6.2 null 안전

- null에 의한 오류가 아예 발생하지 않게 만드는 구조
- 코틀린은 기본적으로 모든 자료형에 null 안전 자료형을 사용한다. null을 할당하는 코드는 컴파일조차 되지 않는다.

## 9.7 예외를 catch하고서 무시하는 코드

```java
try {
	reservations.add(product);
} catch (Exception e) {
}
```

### 9.7.1 원인 분석을 어렵게 만듦

- 이런 코드의 문제는 오류가 나도, 오류를 탐지할 방법이 없어진다. 어느시점에 어떤 코드에서 문제가 발생했는지 찾기 힘들다.
- 데이터에 문제가 생기는 등 잘못된 상태에 빠져도, 외부에서는 아무런 문제가 없는 것처럼 보인다.

### 9.7.2 문제가 발생했다면 소리치기

- catch 구문에서는 최소한 로그로 기록하고, 상위 레이어의 클래스로 오류를 통지하는 것이 좋다.

## 9.8 설계 질서를 파괴하는 메타 프로그래밍

- 프로그램 실행 중에 해당 프로그램 구조 자체를 제어하는 프로그래밍. 용법과 의도를 제대로 이해하지 못하고 사용했을 때 매우 위험하다.
- 자바에서는 메타 프로그래밍을 활용해 클래스 구조를 읽고 쓸 때 리플렉션 API를 사용한다. 이를 통해 일반적인 프로그래밍에서는 접근할 수 없는 부분까지 접근할 수 있다.

```java
class Level {
	private static final int MIN = 1;
	private static final int MAX = 99;
	final int value;
	
	static Level initialize() {
		return new Level(MIN);
	}
}
```

- 인스턴스 변수에 final이 붙어 있으므로, 이후에 변경할 수 없다. 또한 상수를 통해 레벨은 1~99 까지만 지정할 수 있게 했다.
- 하지만 아래의 코드를 실행하면 모든 기대가 무너진다. 불변 변수인 value의 값이 바뀌고, MIN/MAX의 범위를 넘어 999가 된다.

```java
Level level = Level.initialize();
System.out.println("Level : " + level.value);

Field field = Level.class.getDeclaredField("value");
field.setAccessible(true);
field.setInt(level, 999);
```

- 리플랙션을 남용하면 ‘잘못된 상태로부터 클래스를 보호하는 설계’와 ‘영향 범위를 최대한 좁게 만드는 설계’가 아무런 의미도 갖지 못한다.

### 9.8.2 자료형의 장점을 살리지 못하는 하드 코딩

```java
User user = (User)generateInstance("customer", "User");
```

- 만약 이렇게 코드를 작성했다고 하면, IntelliJ IDEA에 이름을 한꺼번에 변경해주는 기능을 사용했을 때 User는 단순한 문자열이기 때문에 변경되지 않을 것이다.

### 9.8.3 단점을 이해하고 용도를 한정해서 사용하기

- 메타 프로그래밍을 사용하고 싶다면 시스템 분석 용도로 한정하거나, 아주 작은 범위에서만 활용하는 등 리스크를 최소화해야 한다.

## 9.9 기술 중심 패키징

- 패키지를 구분할 때도 폴더를 적절하게 나누어야 한다.
- 구조에 따라 폴더와 패키지를 나누는 것을 기술 중심 패키징이라고 부른다.
- MVC는 Model, View, Controller라는 3개의 계층으로 나누어 설계하는 아키텍처 구조이다. 이와 같은 형태가 기술 중심 패키징이라고 할 수 있다.
- 장바구니 엔티티, 안전 재고량 등 비즈니스 개념을 나타내는 클래스를 비즈니스 클래스라고 부른다. 이러한 비즈니스 클래스를 기술 중심 패키징에 따라 폴더를 구분하면 관련성을 알기 매우 힘들다.
- 비즈니스 클래스는 관련된 비즈니스 개념을 기준으로 폴더를 구분하는 것좋다.

## 9.10 샘플 코드 복사해서 붙여넣기

- 그대로 복사하고 붙여 넣어 구현하면, 설계 측면에서 좋지 않은 구조가 되기 쉽다.
- 샘플 코드는 어디까지나 참고만 하고, 클래스 구조를 잘 설계해서 사용해야 한다.

## 9.11 은 탄환

- 새로운 기술을 익히면 곧바로 써보고 싶어지지만 현실에서 발생하는 여러 문제는 특정 기술 하나로 해결할 수 있을 정도로 단순하지 않다.
- 문제를 해결하기 위해 상황을 고려하지 않고 ‘자신이 알고 있는 편리한 기술’을 활용해버리면 문제가 해결되기는 커녕 더 심각해질 수 잇다.
- 중요한 것은 어떤 문제가 있르 때, 어떤 방법이 해당 문제에 효과적인지, 비용이 더 들지는 않는지 평가하고 판단하는 자세이다. 문제와 목적을 머릿속에 새겨두고, 적절한 기술을 선택할 수 있도록 노력하자!
- 설계에 Best라는 것은 없다. 항상 Better를 목표로 할 뿐이다.
