# 15장 설계의 의의와 설계를 대하는 방법

## 15.1 이 책은 어떤 설계를 주제로 집필한 것인가?

| 품질 특성 | 설명 | 품질 관련 부가적인 특성 |
| --- | --- | --- |
| 기능 적합성 | 기능이 니즈를 만족하는 정도 | 기능 무결성, 기능 정확성, 기능 적절성 |
| 성능 효율성 | 리소스 효율과 성능 정도 | 시간 효율성, 자원 효율성, 용량 만족성 |
| 호환성 | 다른 시스템과 정보 공유, 교환할 수 있는 정도 | 공존성, 상호 운용셔ㅓㅇ |
| 사용성 | 사용자가 시스템을 만족하며 사용하는지 나타내는 정도 | 적절도 인식성, 습득성, 운용 조작성, 사용자 오류 방지성, 사용자 인터페이스 편의성, 접근성 |
| 신뢰성 | 필요할 때 기능을 실행할 수 있는 정도 | 성숙성, 가용성, 장애 허용성, 회복성 |
| 보안 | 허용되지 않은 사용으로부터 보호할 수 있는 정도 | 기밀성, 무결성, 부인 방지성, 책임 추적성, 인증성 |
| 유지 보수성 | 시스템이 정상 운용되도록 유지 보수하기가 얼마나 쉬운가를 나타내는 정도 | 모듈성, 재사용성, 분석성, 수정성, 시험성 |
| 이식성 | 다른 실행 환경에 이식할 수 있는 정도 | 적응성, 설치성, 치환성 |
- 소트트웨어 품질과 관련된 특성을 표로 나타낸 것
- 소프트웨어에서 설계란 소프트 웨어의 품질 특성을 향상시키기 위한 구조를 만드는 것이다.
- 이 책에서 그동안 다룬 내용은 악마의 성질과 가장 관련있는  유지보수성 특히 변경 용이성을 목적으로 하는 설계 방법을 다루었다.
- 수정성은 변경 용이성이라고도 하며 얼마나 쉽고 정확하게 코드를 변경할 수 있는지를 목적으로 설계 방법을 다루어왔다.

## 15.2 설계하지 않으면 개발 생산성이 저하된다.

- 레거시 코드: 변경하기 어렵고 버그가 생기기 쉬운 코드
- 기술부채 : 레거시 코드가 축적되어 있는 상태

- 변경 용이성 설계를 하지 않으면 개발 생산성이 저하된다  저하 요인으로는 크게 두 가지가 있다.

### 15.2.1 요인 1: 버그가 발생하기 쉬운 구조

- 코드 변경 시 버그가 발생하기 쉽다면 버그가 발생하지 않게 하면서 정확히 변경하는 데 시간이 오래 걸린다.
    - 응집도가 낮은 구조로 인해 사양 변경 시 수정 누락이 발생하기 쉬워지고, 결국 버그가 발생한다.
    - 코드를 이해하기 어려우므로 구현할 때 실수를 저지르기 쉽다.
    - 잘못된 값이 들어오기 쉬워진다.


### 15.2.2 요인2: 가독성이 낮은 구조

- 가독성이 저하되면, 의도를 정확하게 이해하는데 시간이 오래 걸린다.
    - 관련된 로직이 이곳저곳에 흩어져 있어 사양 변경시 관련 로직을 찾는 시간이 오래 걸린다.
    - 잘못된 값이 들어와 버그가 발생했을 때, 잘못된 값 출처를 추적하기 어렵다.

### 15.2.3 나무꾼의 딜레마

- 나무꾼이 도끼로 나무를 베고 있는데 잘 베어지지 않자 여행자가 “도끼를 갈고 나무를 베는 것이 좋지 않을까요?”라고 물었다. 하지만 나무꾼은” 알고 있지만 나무를 베는 것이 바빠서 도끼를 갈 시간이 없어요!” 라고 대답한 이야기
- 제대로 설계하지 않으면 로직 변경과 디버그에 많은 시간을 소비하게 된다.

### 15.2.4 열심히 일했지만 생산성이 나쁨

- 개발 생산성이 나쁘면 새로운 기능을 릴리스하는데 오래 걸린다.
- 그렇게 되면 성과를 낼 수 없다.
- 출시 기일을 맞추기 위해 장시간 노동이 이루어지는데 어떻게든 작동하게 만들려고 구현과 수정을 반복하게 된다면 열심히 일했는데 성과를 내기 어렵다.

### 15.2.5 국가 규모의 경제 손실

- 복잡하고 이해하기 힘든 로직이 있으면, 이로 인해 더 복잡하고 이해하기 힘든 로직이 만들어진다.
- 소스 코드가 점점 거대해지면 릴리스가 어려워질 정도로 악화된다.
- 일본의 경제 산업성 발표 자료에 따르면 일본 내부의 기술 부채로 인한 경제적 손실이 12조엔 정도 될 것으로 예상했다.
- 설계를 소홀히 하고 매일 낮은 생산성을 방치하면 국가 규모의 손실이 발생하고 있는 것이다.

## 15.3 소프트웨어와 엔지니어의 성장 가능성

- 소프트웨어의 가치와 매력을 높이기 위해 사양을 추가하고 변경하면서 코드를 변경한다.
- 코드의 변경 용이성이 높을수록 소프트어의 가치를 빠르게 높일 수 있다.
- 즉 변경 용이성을 높이는 것은 소프트웨어의 성장 가능성을 높이는 것과 같다.

### 15.3.1 엔지니어에게 자산이란 무엇인가?

- 엔지니어의 자산은 기술력이다.
- 하지만 레거시 코드는 이러한 자산의 축적, 기술력 성장을 방해하는 무서운 존재이다.

### 15.3.2 레거시 코드는 발전을 막음

- 레거시 코드가 많은 프로젝트를 신입사원이나 후임 담당자가 개발을 담당하게 되면 작성 코드가 레거시 코드라는 것을 알아보기 어렵다.
- 오히려 좋은 코드, 효율적인 코드라고 생각해 레거시 코드를 추가로 양산하게 된다.
- 레거시 코드는 다른 사람으로 하여금 레거시 코드를 작성하게 되어 낮은 수준의 기술만 사용하게 만든다.

### 15.3.3 레거시 코드는 고품질 설계 경험을 막음

- 레거시 코드임을 알아차려도 이미 균형이 깨져 있어 설계를 개선하기 힘들다.
- 결국 프로젝트 납기 일정 등으로 설계 개선을 포기하게 되고 고품질 설계 구현 경험을 쌓을 수 없어 설계 능력이 향상되지 않는다.

## 15.4 문제 해결하기

### 15.4.1 문제를 인식하지 못하면 설계에 대한 생각 자체가 떠오르지 않음

- 막 걷기 시작한 아이는 교통사고의 두려움을 모르므로 어른이 손을 잡고 교통 규칙을 열심히 알려줘야 한다.
- 프로그래밍도 마찬가지로 문제를 인지하지 못하면 설계에 대한 생각이 떠오르지 않는다.

| 소프트웨어가치메트릭 | 보임 | 보이지 않음 |
| --- | --- | --- |
| 플러스가치 | 신기능 | 아키텍처  |
| 마이너스 가치  | 버그 | 기술 부채  |

### 15.4.2 인지하기 쉬운 문제와 인지하기 어려운 문제가 있음

- 필립 크뤼슈텐이 소프트에어 시스템에 대해 정의한 메트릭
- 보이는 쪽은 내부 구조에 대한 이해가 없어도 인식 할 수 있는 것이다.
- 보이는 쪽의 플러스 가치는 신기능, 마이너스 가치는 버그이다.
- 반면 보이지 않는 쪽은 플러스 가치로 아키텍처, 마이너스 가치로 기술 부채가 있다.
- 엔지니어라면 보이지 않는 쪽의 가치를 볼 수 있을까?
- 어떤 코드가 어떤 문제를 일으키는지 모른다면, 기술 부채의 존재를 인식하기 힘들다.

### 15.4.3 이상적인 형태를 알아야 문제를 인식할 수 있음

- 공수도의 움직임은 다리의 방향, 고관절의 열림등 이상적인 형태가 있다.
- 이처럼 설계에서도 이상적인 설계와 현재 설계를 비교하면 기술 부채를 인식할 수 있다.

### 15.4.4 변경 용이성을 비교할 수 없는 딜레마

- 기술 부채를 줄이는 변경 용이성 설계 효과는?
- 변경 용이성은 개발 생산성으로 추측은할 수 있지만, 성능과 달리 곧바로 비교할 수 없다.
- 미래의 변경 비용이 얼마나 낮은지 나타내는 것으로 시간이 경과해야 알 수 있다.

## 15.5 코드의 좋고 나쁨을 판단하는 지표

- 미래의 개발 생산성을 측정할 수 있는 방법은 없지만 소스 코드의 좋고 나쁨을 판단하는 지표는 있다.
- 코드 복잡성과 가독성 등의 품질 지표를 코드 메트릭 또는 소프트웨어 메트릭이라고 부른다.
- 코드 메트릭과 그 분석 도구를 몇 가지 소개하겠습니다.

### 15.5.1 실행되는 코드의 줄 수

- 주석을 제외하고 실행되는 로직을 포함하는 코드의 줄수가 많을수록 많은 일을 하고 있을 가능성이 높다.

| 스코프 | 줄 수 상한 |
| --- | --- |
| 메서드 | 10줄 이내 |
| 클래스  | 100줄 이내 |
- 같은 기능을 수행하더라도 로직을 구현하는데 필요한 코드의 양은 프로그래밍 언어에 따라 조금씩 다르다. 하지만 어떤 언어를 사용해도 이정도가 적당하다.
- 줄 수가 많으면 메서드와 클래스 분할을 검토해보자

### 15.5.2 순환 복잡도

- 순환 복잡도는 코드의 구조적인 복잡함을 나타내는 지표
- 조건 분기, 반복 처리, 중첩이 많아지면 복잡도가 커진다.

-순환 복잡도의 기준 표-

| 순환 복잡도 | 복잡함의 상태 | 버그 확률 |
| --- | --- | --- |
| 10 이하 | 굉장히 좋은 구조 | 25% |
| 30 이상 | 구조적인 리스크가 존재 | 40% |
| 50 이상 | 테스트 불가능 | 70% |
| 75 이상 | 변경할 때 반드시 실수가 발생 | 98% |
- 조건 분기, 반복 처리, 중첩은 복잡도를 높인다.
- 조기 리턴 전략 패턴, 일급 컬렉션 등 테크닉을 활용하면 복잡도를 줄일 수 있다.
- 데이터 클래스는 로직이 따로 없으므로 복잡도가 0이지만 다른 클래스의 복잡도에 영향을 줄 수 있으므로 주의해야 한다.

### 15.5.3 응집도

- 응집도는 모듈(클래스, 패키지, 레이어 등) 내부에서 데이터와 로직이 관련되어 있는 정도를 나타내는 지표이다.
- 클래스로 해석하자면 클래스 내부에서 데이터와 로직의 관계가 얼마나 강한지 나타내는 지표
- 구체적으로 인스턴스 변수와 그인스턴스 변수를 사용하는 로직이 같은 클래스에 구현되어 있으면 응집도가 높다고 할 수 있다.
- 응집도가 높을 수록 변경 용이성이 높은 구조이다.
- 응집도를 나타내는 메트릭으로 LOOM이 있다.

### 15.5.4 결합도

- 결합도는 모듈 간의 의존도를 나타내는 지표
- 클래스의 결합도는 어떤 클래스가 호출하는 다른 클래스의 수
- 즉 의존하고 있는 클래스가 많을수록, 즉 결합도가 높을수록 넓은 범위를 고려해야하므로 유지보수와 사양 변경이 어렵다.
- 결합도는 분석도구를 사용하거나, 호출하는 클래스의 수를 세거나 클래스 다이어그램을 그려보면 알 수 있다.
- 결합도가 너무 높으면 단일 책임 원칙을 위배하고 있을 수 있기 때문에 검토해보는 것이 좋다.

### 15.5.5 청크

- 인간이 기억할 수 있는 정보 덩어리 단어를 청크라고 부른다.
- 인지 심리학 연구 결과에 따르면 인간 단기 기억은 4+-1 개념 정도만 파악할 수 있다.
- 클래스에서도 뇌가 쉽게 받아들일 수 있도록 클래스에서 다루는 개념이 4+-1정도가 되도록 설계하고 이보다 큰 클래스는 작은 클래스로 분할하는 것이 좋다.
- 클래스의 크기와 관계없이 다루는 개념의 개수는 시스템 전체로 보았을 때 그대로이니 차이가 없을 거 같으나 강하게 연결된 개념끼리 응집시켜서 작은 클래스로 분할해 두면 관계를 훨씬 쉽게 파악할 수 있다.
- 단일 책임 원칙을 준수하면 쉽게 매지컬 넘버에 맞출 수 있다.

## 15.6 코드 분석을 지원하는 다양한 도구

- 소스 코드를 분석해서 다양한 메트릭을 계측해 주는 도구가 있다.

### 15.6.1 Code Climate Quality

- Code Climate사에서 만든 코드 품질 분석도구
- 깃허브와 연동하면 리포지터리에 저장된 코드의 품질 점수를 자동으로 계산해준다.
    - 자체 계산식을 통해 기술 부채를 산출, 부채의 증감을 시계열 그래프로 보여준다.
    - 부채의 정도를 파일 단위로 시각화한다. 정렬도 가능
    - 복잡도와 코드 줄 수 등 메트릭상에서 문제가 있는 부분을 시각화한다.
    - 파일별로 변경 빈도를 가로축, 기술 부채를 세로축으로 하는 그래프를 만든다.
        - 변경 빈도와 부채가 클수록 부채를 해소했을 때 얻는 가치가 크며 개발 생산성 향상에 기여한다.

### 15.6.2 Understand

- Scientific Toolworks,Inc의 코드 품질 분석 도구
- 코드 줄 수 , 복잡도, 응집도, 결합도 이외에도 다양한 관점의 메트릭을 계측
- 클래스와 메서드 사이의 의존 관계를 시각화하는 그래픽뷰라는 기능을 갖고있다.
- 사양 변경 시 영향 범위 파악하기 편리하고 영향 범위를 줄일 수 있다.

### 15.6.3 Visual Studio

- Microsoft에서 만든 IDE(통합 개발 환경)이다.
- 무료로 사용할 수 있는 Community 버전을 포함해서, 모든 라이선스 형태에서 코드 메트릭 계산 기능을 사용할 수 있다.
- 실행 가능한 코드의 줄 수, 복잡도, 결합도를 분석하고 전체적인 부채 정도를 나타내는 유지 보수 용이성 인덱스를 계산해준다.
- 이러한 지표를 메서드, 클래스, 패키지 단로 계산할 수도 있다.

<aside>
💡 일반적인 에디터에는 구문 강조 기능이 있다. 구문 강조는 코드의 특정 기호, 키워드 구문을 다른 색상으로 표시하는 기능인데 이를 활용해 코드 품질을 시각화한다.
문제를 일으키는 쉬운 코드에는 경고를 나타내는 붉은색, 주황색을 사용하고 
코드 품질을 유지하는데 유용한 코드에는 안전을 나타내는 색상을 사용한다.
이와 같이 설정하면 어떤 부분을 개선하면 좋을지 쉽게 색으로 구분할 수 있다.

</aside>

## 15.7 설계 대상과 비용 대비 효과

- 회사의 예산은 유한하기 때문에 유한한 예산 안에서 개발 비용이 산출된다.
- 투자한 비용과 제한된 기간 내에 이익을 내야하기 때문에 설계와 리팩터링을 무한히 할 수 없다.
- 현실적으로 프로젝트의 소스 코드가 전반적으로 나쁘다고 해도, 설계를 바꿔 개선할 수 있는 부분은 일부이다.
- 비용의 제약이 있다면 구조가 조악하더라도 버그없이 잘 작동되고 사양 변경이 일어나지 않는다면 비용을 들여 변경 용이성을 높이는 것은 낭비다.
- 이처럼 비용 대비 효과가 높은 부분을 노려야한다.

### 15.7.1 파레토의 법칙(80:20의 법칙)

- 파레토의 법칙은 전체 결과 80%는 전체 원인의 20%에서 일어난다는 법칙으로 ‘소프트 웨어의 처리 시간 중 80%는 소스 코드 전체의 20%가 차지한다’는 현상에 비유된다.
- 소프트웨어의 기능 전체 중 중점으로 사용되는 기능은 1/3정도 밖에 되지않는다. 마찬 가지로 사양이 자주 바뀌는 곳도 일부 한정되어있다.
- 그러므로 중요하고 사양 변경이 빈번한곳의 설계를 개선하면 비용 대비 효과가 높다.

### 15.7.2 코어 도메인: 서비스의 중심 영역

- 모든 상품과 서비스는 이것이 우리가 판매하는 것이라고 말할 수 있는 중심 가치가 있다.
- 이처럼 서비스에서 중심이 되는 비즈니스 영역을 코어 도메인이라고 한다.
    - 시스템에서 가장 큰 가치를 창출하는 곳
    - 가치 있고 중요하고 비용 대비 효과가 가장 큰 곳
    - 경쟁 우위에 있고 차별점을 만들며, 비즈니스 우위를 만들 수 있는 곳
- 설계에 비용을 투자해야 하는 곳, 비용 대비 효과 큰 곳이라고 할 수 있다.

### 15.7.3 중점 설계 대상 선정에는 비즈니스 지식이 필요함

- 서비스는 런칭 후 다양한 기능이 추가되어 무엇이 서비스의 중심 가치인지 알기 힘들어진다.
- Code Climate Quality 같은 분석 도구를 사용하면 변경 빈도가 높은 곳을 찾을 수 있다.
- 도메인 주도 설계는 코어 도메인의 가치를 지속적으로 높이고 서비스를 장기적으로 성장시키는 방법이다.
- 사업 영역과 관련된 지식이 풍부한 도메인 전문가와 협력해서 무엇이 코어 도메인인지 잘 판별해야한다.

- 설계 비용 대비 효과를 높이려면 중점적인 설계 대상을 선정할 수 있어야 한다.
- 대상을 잘 선정하기 위해선 서비스와 관련된 비즈니스 지식이 필요하다.
- 구조의 좋고 나쁨에만 주목하면 설계가 비즈니스 전략을 제대로 뒷받침하지 못할 수도 있다.
- 소프트웨어 엔지니어 중에는 아키텍트라는 직종이 있다.
- 아키텍트는 비즈니스 전략을 실현하는 아키텍처를 설계하는 역할을 한다.
- 성장 가능성을 높이기 위한 최적의 설계와 비즈니스 지식은 뗄 수 없는 관계

## 15.8 시간을 다스리는 능력자 되기

- 변경 용이성 설계는 개발 생산성을 향상시킨다. 특히 미래의 시간을 다스릴 수 있다.
- 현재의 설계 품질은 미래에 소비할 시간에 직접적인 영향을 준다.
- 걸리는 시간을 신경쓰며 개발하다 보면 ‘디버깅 시간이 길다’ ‘코드를 읽는데 오래 걸린다’처럼 평소 개발 시 발생하는 ‘쓸데없는 시간’이 느껴질 것이다.
- 엔지니어가 아닌 사람들은 시스템의 표면적인 기능만 본다. 하지만 시스템을 개발하는 엔지니어는 내부 구조를 머릿속에 그릴 수 있다.
- 어려운 능력이지만 누구나 훈련하면 습득할 수 있다.
- 머릿속에 그리는 능력과 설계 능력을 활용하면 미래의 시간을 조종할 수 있다.
